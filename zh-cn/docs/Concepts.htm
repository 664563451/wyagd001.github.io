<!DOCTYPE HTML>
<html>
<head>
<title>概念和约定</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>概念和约定</h1>
<p>本文档涵盖了 AutoHotkey 所使用的一些通用概念和约定, 重点放在解释而不是代码上. 不会假定读者之前具备任何脚本或编程的知识, 但应该准备学习的新术语.</p>
<p>有关语法的更多具体细节, 请参阅 <a href="Language.htm">脚本语言</a>.</p>

<h2>目录</h2>
<ul>
  <li><a href="#values">值</a>
  <ul>
    <li><a href="#strings">字符串</a></li>
    <li><a href="#numbers">数字</a></li>
    <li><a href="#boolean">布尔值</a></li>
    <li><a href="#nothing">空值</a></li>
    <li><a href="#objects">对象</a></li>
    <li><a href="#object-protocol">对象协议</a></li>
  </ul></li>
  <li><a href="#variables">变量</a>
  <ul>
    <li><a href="#uninitialised-variables">未初始化变量</a></li>
    <li><a href="#built-in-variables">内置变量</a></li>
    <li><a href="#environment-variables">环境变量</a></li>
    <li><a href="#caching">缓存</a></li>
  </ul></li>
  <li><a href="#functions">函数/命令</a></li>
  <li><a href="#control-flow">控制流</a></li>
  <li><a href="#details">细节</a>
  <ul>
    <li><a href="#string-encoding">字符编码</a></li>
    <li><a href="#pure-numbers">纯数字</a></li>
    <li><a href="#names">名称</a></li>
    <li><a href="#variable-references">变量引用与值</a></li>
    <li><a href="#references-to-objects">对象的引用</a></li>
  </ul></li>
  </ul>
</ul>
<!-- TODO:
Scope/declarations
Technical terms: dynamic, default
Classes
Exception handling
-->

<h2 id="values">值</h2>
<p><em>值</em> 只是程序中的一条信息. 例如, 要发送的键名或要运行的程序名, 键被按下的次数, 要激活的窗口的标题, 或在程序或脚本中具有某种意义的其他任何内容.</p>
<p>AutoHotkey 支持这些类型的值:</p>
<ul>
  <li><a href="#strings">字符串</a>(文本)</li>
  <li><a href="#numbers">数字</a>(整数和浮点数)</li>
  <li><a href="#objects">对象</a></li>
</ul>
<p>其他一些相关的概念:</p>
<ul>
  <li><a href="#boolean">布尔值</a></li>
  <li><a href="#nothing">空值</a></li>
</ul>

<h3 id="strings">字符串</h3>
<p><em>字符串</em> 只是文本. 每个字符串实际上是一个序列或由字符组成的 <em>字符串</em>, 但可以视为单个实体. 字符串的 <em>长度</em> 是序列中字符的数量, 而字符串中字符的 <em>位置</em> 只是该字符的序号. 按惯例在 AutoHotkey, 第一个字符在位置 1.</p>
<p>当数学运算或比较需要时, 数字字符串(或任何其他受支持的 <a href="#numbers">数字格式</a>) 自动解释为数字.</p>
<p>文本在脚本中的书写方式取决于上下文. 有关详细信息, 请参阅 <a href="Language.htm#legacy-syntax">传统语法</a> 和 <a href="Language.htm#strings">字符串(在表达式中)</a>.
<p>有关字符串如何工作的更详细说明, 请参阅 <a href="#string-encoding">字符编码</a>.</p>

<h3 id="numbers">数字</h3>
<p>AutoHotkey 支持这些数字格式:</p>
<ul>
  <li>十进制整数, 如 <code>123</code>, <code>00123</code> 或 <code>-1</code>.</li>
  <li>十六进制整数, 如 <code>0x7B</code>, <code>0x007B</code> 或 <code>-0x1</code>.</li>
  <li>十进制浮点数, 如 <code>3.14159</code>.</li>
</ul>
<p>除本文档注明外, 十六进制数字必须使用 <code>0x</code> 或 <code>0X</code> 前缀. 这个前缀必须写 <code>+</code> 或 <code>-</code> 符号之后(如果存在), 并且在前导零之前. 例如, <code>0x001</code> 有效, 但 <code>000x1</code> 无效.</p>
<p>带小数点的数字总是被认为是浮点数, 即使小数部分是零. 例如, <code>42</code> 和 <code>42.0</code> 通常可以互换, 但并非总是如此. 科学记数法也是公认的, 但前提是存在一个小数点(如 <code>1.0e4</code> 和 <code>-2.1E-4</code>).</p>
<p>小数点分隔符总是一个点, 即使用户的区域设置指定了一个逗号.</p>
<p>当数字被转换为字符串时, 它是根据当前的 <a href="commands/SetFormat.htm#General_Remarks">整数或浮点格式</a> 进行格式化. 尽管 <a href="commands/SetFormat.htm">SetFormat</a> 命令可以用来更改当前的格式, 但通常使用 <a href="commands/Format.htm">Format</a> 函数格式化字符串会更好. 浮点数也可以使用 <a href="commands/Math.htm#Round">Round</a> 函数进行格式化.</p>
<p>有关数字值的范围和精度的详细信息, 请参阅 <a href="#pure-numbers">纯数字</a>.</p>

<h3 id="boolean">布尔值</h3>
<p><em>布尔值</em> 可以是 <em>真</em> 或 <em>假</em>. 布尔值用于表示具有两种可能状态的任何东西, 例如表达式的 <em>真值</em>. 例如, 当 x 小于或等于 y 的值时, 表达式 <code>(x &lt;= y)</code> 是 <em>真</em>. 布尔值也可以表示 <em>是</em> 或 <em>否</em>, <em>开</em> 或 <em>关</em>, <em>下</em> 或 <em>上</em> (如 <a href="commands/GetKeyState.htm">GetKeyState</a>) 等等.</p>
<p>AutoHotkey 没有特定的布尔类型, 因此它使用整数值 <code>0</code> 表示假, 而 <code>1</code> 表示真. 当要求判断一个值的真假时, 空白或零值被认为是假, 而所有其他值被认为是真. (对象总是被视为真.)</p>
<p>单词 <code>true</code> 和 <code>false</code> 是是值分别为 1 和 0 的<a href="#built-in-variables">内置变量</a>. 使用它们可以增加脚本的可读性.</p>

<h3 id="nothing">空值</h3>
<p>AutoHotkey 中没有像其他语言那样有一个独特的表示 <em>nothing</em>, <em>null</em>, <em>nil</em> 或 <em>undefined(未定义)</em> 的值. 相反, 一个空字符串(长度为零的字符串) 通常具有这个含义.</p>
<p>如果一个 <a href="#variables">变量</a> 或参数被称为 &quot;空&quot; 或 &quot;空白&quot;, 通常意味着一个空字符串(长度为零的字符串).</p>

<h3 id="objects">对象</h3>
<p>通常有两种方式查看对象:</p>
<ul>
  <li>一个对象包含一组值, 允许这组值本身被视为一个值. 例如, 一个对象可以包含一个 <em>数组</em> 或一系列的项目, 或者一组相关的值, 如屏幕上一个位置的 X 坐标和 Y 坐标. 通过将对象与其他对象组合, 对象可用于构建复杂的结构.</li>
  <li>一个对象可以表示一个 <em>事物</em>, 一个 <em>服务</em>, 或其他东西, 并且可以为脚本提供与这个事物或服务交互的方法. 例如, <em>BankAccount(银行账户)</em> 对象可能具有诸如账号, 当前余额和账户所有者等属性, 以及提取或存入金额的方法.</li>
</ul>
<p>适当的使用对象(特别是 <a href="Objects.htm#Custom_Classes">classes(类)</a>) 能产生 <em>模块化</em> 和 <em>可重复使用</em> 的代码. 模块化代码通常更容易测试, 理解和维护. 例如, 人们可以改进或修改一段代码, 而不需要知道其他段的细节, 也不必对这些段做相应的修改. 可重复使用的代码节省了时间, 避免了一遍又一遍地为相同或相似的任务编写和测试代码.</p>
<p>当你将一个对象赋值给一个 <a href="#variables">变量</a> 时, 如 <code>myObj := {}</code>, 你存储的不是对象本身, 而是对象的 <a href="#references-to-objects"><em>引用</em></a>. 复制该变量, 如 <code>yourObj := myObj</code>, 创建一个新的对 <em>同一</em> 对象的引用. 如 <code>myObj.ans := 42</code> 这样的改变会影响 <code>myObj.ans</code> 和 <code>yourObj.ans</code>, 应为它们都指向同一个对象. 但是, <code>myObj := Object()</code> 只影响变量 <em>myObj</em>, 不影响变量 <em>yourObj</em>, yourObj 仍然指向原始对象.</p>

<h3 id="object-protocol">对象协议</h3>
<p class="note">本节以这些概念为基础, 这些概念将在后面的章节中介绍: <a href="#variables">变量</a>, <a href="#functions">函数</a></p>
<p>对象通过 <em>消息传递</em> 的原理工作. 您不知道对象的代码或变量实际驻留在哪里, 因此您必须将消息传递给对象, 如 &quot;give me <em>foo</em>&quot; 或 &quot;go do <em>bar</em>&quot;, 并依赖对象来响应消息. AutoHotkey 中的对象支持以下基本消息:</p>
<ul>
  <li><strong>Get(获取)</strong> 一个值.</li>
  <li><strong>Set(设置)</strong> 一个值, 使用 <code>:=</code>.</li>
  <li><strong>Call(调用)</strong> 一个方法, 使用 <code>()</code>.</li>
</ul>
<p>每个消息可以有一个或多个 <a href="#parameters">参数</a>(对于 <strong>Set(设置)</strong>, 需要值). 通常至少有一个参数, 它被解释为属性或方法的名称, 键或数组索引, 具体取决于对象以及使用方法. 消息的参数使用三种不同的模式指定: <code>.Name</code>, <code>[Parameters]</code> 和 <code>(Parameters)</code>, 其中 <em>Name</em> 是文字的 <a href="#names">名称或标识符</a>, <em>Parameters</em> 是参数列表(如子表达式), 可以是空/空白(<code>[]</code> 或 <code>()</code>).</p>
<p>对于 <strong>Get(获取)</strong> 和 <strong>Set(设置)</strong>, <code>.Name</code> 和 <code>[Parameters]</code> 可以互换使用, 也可以组合使用:</p>
<pre>myObj[arg1, arg2, ..., argN]
myObj.name
myObj.name[arg2, ..., argN]
</pre>
<p>对于 <strong>Call(调用)</strong>, <code>.Name</code> 和 <code>[Parameter]</code> 可以互换使用, 并且必须总是跟着 <code>(Parameters)</code>:</p>
<pre>myObj.name(arg2, ..., argN)
myObj[arg1](arg2, ..., argN)
</pre>
<p>请注意, 如果 <code>name</code> 已经存在, 它将成为第一个参数. <code>myObj.name</code> 相当于 <code>myObj[&quot;name&quot;]</code>, 而 <code>myObj.123</code> 相当于 <code>myObj[123]</code>. 这适用于所有类型的对象, 因此总是可以在运行时计算属性或方法的名称, 而不是将其硬编码到脚本中.</p>
<p>虽然 <em>name</em> 或 <em>arg1</em> 被认为是第一个参数, 但是请记住这些只是 <em>消息</em>, 而且对象可以以任何方式自由处理它们. 在如上所示的方法调用中, 通常对象使用 <em>name</em> 或 <em>arg1</em> 来标识哪个方法应该被调用, 然后只有 <em>arg2</em> 和之后的部分被传递给方法. 实际上, <em>arg2</em> 成为方法的第一个表观参数.</p>
<p>一般来说, <strong>Set</strong> 与赋值有相同的含义, 所以它使用相同的运算符:</p>
<pre>myObj[arg1, arg2, ..., argN] := value
myObj.name := value
myObj.name[arg2, ..., argN] := value
</pre>
<p>目前, <strong>Set</strong> 允许使用 &quot;hybrid(混合)&quot; 语法, 但最好不要使用它:</p>
<pre>myObj.name(arg2, ..., argN) := value
</pre>
<p>从技术上讲, <code>value</code> 作为 <em>Set</em> 消息的最后一个参数传递; 然而, 这个细节几乎与脚本作者无关. 一般来说, 人们可以简单地将其视为 &quot;被赋值的值&quot;.</p>

<h2 id="variables">变量</h2>
<p>一个变量允许您使用一个名称作为一个值的占位符. 在脚本运行期间, 这个值可能会重复更改. 例如, 一个热键可以使用一个变量 <code>press_count</code> 来计算它被按下的次数, 并且当 <code>press_count</code> 是 3 的倍数(每第三次按下) 时, 发送一个不同的键. 即使只有一次赋值的变量也是有用的. 例如, <code>WebBrowserTitle</code> 变量可用于在更改首选 Web 浏览器时更容易更新代码, 或者由于软件更新而导致 <a href="misc/WinTitle.htm">title</a> 或 <a href="misc/WinTitle.htm#ahk_class">window class</a> 发生更改.</p>
<p>在 AutoHotkey 中, 需要使用它们时就可以创建变量. 每个变量都 <em>不是</em> 永久性地限制在一个 <a href="#values">数据类型</a> 中, 而是可以保存任何类型的值: 字符串, 数字或对象. 每个变量从空/空白开始; 换句话说, 每个新创建的变量都包含一个空字符串, 直到它被赋予其他值.</p>
<p>一个变量有三个主要方面:</p>
<ul>
  <li>变量的 <em>名称</em>.</li>
  <li>变量本身.</li>
  <li>变量的 <em>值</em>.</li>
</ul>
<p>某些适用于变量名称的限制 - 请参阅 <a href="#names">Names</a> 了解详细信息. 简而言之, 坚持使用由 ASCII 字母(不区分大小写), 数字和下划线组成的名称是最安全的, 并避免使用以数字开头的名称.</p>
<p>变量名称具有 <strong><em>作用域(范围)</em></strong>, 该范围定义了代码中的哪些位置可使用变量名称来引用该特定变量; 换句话说, 哪些位置变量是 <em>visible(可见的)</em>. 如果一个变量在一个给定的范围内是不可见的, 那么相同的名称可以引用一个不同的变量. 两个变量可能同时存在, 但只有一个对脚本的每个部分是可见的. <a href="Functions.htm#Global">全局变量</a> 在 "全局范围" (即函数之外) 中是可见的, 但通常必须 <a href="Functions.htm#Global">声明</a> 为使其在函数内可见. <a href="Functions.htm#Local">局部变量</a> 只在创建它们的函数内部可见.</p>
<p>一个变量可以被认为是一个值的容器或存储位置, 所以你会经常发现文档引用变量的值作为 <em>变量的内容</em>. 对于变量 <code>x := 42</code>, 我们也可以说变量 x 的值是 42, 或者 x 的值是 42.</p>
<p>值得注意的是, 一个变量和它的值是不一样的. 例如, 我们可以说 &quot;<code>myArray</code> 是一个数组&quot;, 但是我们真正的意思是 myArray 是一个包含对数组的引用的变量. 我们通过使用变量的名称来引用其值, 但是 &quot;myArray&quot; 实际上只是变量的名称; 数组对象不知道它有一个名称, 并且可以被许多不同的变量引用(因此有很多的名称).</p>

<h3 id="uninitialised-variables">未初始化变量</h3>
<p><em>初始化</em> 一个变量是给它分配一个起始值. 虽然程序会自动初始化所?有的变量(一个空字符串是默认值), 但是脚本在使用之前初始化它的变量是一个好习惯. 这样, 任何阅读脚本的人都可以看到脚本将使用哪些变量以及他们预期具有的起始值.</p>
<p>脚本通常需要初始化任何预期包含数字的变量. 例如, 如果 x 从未被赋值 <code>x := x + 1</code> 将不起作用, 因为 <em>空字符串</em> 被认为是非数字的. 脚本应该分配一个起始值, 如 <code>x := 0</code>. 有些情况下空值 <em>是</em> 被假定为 0, 但是最好不要依赖这个方法.</p>
<p>脚本作者可以使用 <a href="commands/_Warn.htm">#Warn</a> 指令来帮助查找变量被使用而未被脚本初始化的情况.</p>

<h3 id="built-in-variables">内置变量</h3>
<p>程序中内置了许多有用的变量, 可以通过任何脚本来引用. 除了 <a href="misc/Clipboard.htm">Clipboard</a>, <a href="misc/ErrorLevel.htm">ErrorLevel</a>, 和 <a href="Scripts.htm#cmd">命令行参数</a> 外, 这些变量是只读的; 也就是说, 他们的内容不能被脚本直接改变. 按照惯例, 这些变量中的大部分以前缀 <code>A_</code> 开头, 所以最好避免使用这个前缀作为你自己的变量.</p>
<p>某些变量如 <a href="Variables.htm#KeyDelay">A_KeyDelay</a> 和 <a href="Variables.htm#TitleMatchMode">A_TitleMatchMode</a> 代表控制脚本行为的设置, 并为每个<a href="misc/Threads.htm">线程</a>保留不同的值. 这允许由新线程(如 hotkeys, menus, timers 等) 启动的子例程在不影响其他线程的情况下更改设置.</p>
<p>一些特殊的变量不是周期性地更新, 而是脚本引用变量时检索或计算它们的值. 例如, <a href="misc/Clipboard.htm">Clipboard</a> 以文本形式检索剪贴板的当前内容, <a href="Variables.htm#TimeSinceThisHotkey">A_TimeSinceThisHotkey</a> 计算自热键被按下以来经过的毫秒数.</p>
<p>相关: <a href="Variables.htm#BuiltIn">内置变量列表</a>.</p>

<h3 id="environment-variables">环境变量</h3>
<p>环境变量由操作系统维护. 在命令提示符中输入 SET 并回车后, 您可以看到环境变量列表.</p>
<p>脚本中可以使用 <a href="commands/EnvSet.htm">EnvSet</a> 创建新的环境变量或改变现有环境变量的内容. 系统的其他部分不会看到这种添加和改变. 但是, 通过调用 <a href="commands/Run.htm">Run</a> 或 <a href="commands/Run.htm">RunWait</a> 启动的任何程序或脚本 会继承其父脚本的环境变量的副本.</p>
<p>推荐在所有新脚本中使用 <a href="commands/EnvGet.htm">EnvGet</a> 来获取环境变量, 例如 Path:</p>
<pre>EnvGet, OutputVar, Path  <em>; 有关解释, 请参阅 #NoEnv.</em></pre>
<p>如果脚本中没有 <a href="commands/_NoEnv.htm">#NoEnv</a> 指令, 则读取一个空变量将返回具有该名称(如果有的话) 的环境变量的值. 这可能会导致混淆, 所以建议所有新脚本使用 <code>#NoEnv</code>.</p>

<h3 id="caching">缓存</h3>
<p>尽管变量通常被认为是持有单个值, 而该值具有不同的类型(字符串, 数字或对象), 但在 <code>myString + 1</code> 和 <code>MsgBox %myNumber%</code> 等情况下, AutoHotkey 会自动在数字和字符串之间进行转换. 由于这些转换可能非常频繁地发生, 因此只要转换了变量, 就会将结果 <em>缓存</em> 在变量中.</p>
<p>实际上, 变量可以同时包含一个字符串和一个数字. 通常, 这只是为了改善脚本的性能不下降, 但是如果变量同时包含一个字符串和一个数字, 那它是数字, 还是一个字符串呢? 在至少两种情况下, 这种多义性会导致意外行为:</p>
<ol>
  <li>COM 对象. 为了将参数传递给 COM 对象, 程序必须将变量的内容转换为数字 <em>或</em> 字符串. 如果传递错误类型的值, 某些 COM 对象会引发异常. 如果一个变量同时具有数字和字符串, 则使用数字. 通常这会得到正确的结果, 但有时不会.</li>
  <li>对象不能将数字和字符串存储为键或值. 由于数字的内存效率更高, 因此如果一个变量同时具有两者, 则使用数字(除了用作键的浮点值).</li>
</ol>
<p><a href="commands/SetFormat.htm">SetFormat</a> 的慢速模式强制分配一个纯数字, 以便立即将该数字转换为一个字符串. 对于整数, 这个数字也被存储, 所以除了性能之外, 这不会有不利的影响. 对于浮点数, 不存储数字, 因为 SetFormat 会影响值的精度, 甚至可能会截断所有的小数位数. 换句话说, SetFormat 的慢速模式可防止纯浮点数存储在变量中.</p>
<p>取一个变量的地址有效地将变量的值转换为一个字符串, 禁用缓存直到变量的地址改变(这发生在容量改变时). 这既是为了向后兼容, 也是因为脚本可以随时通过其地址间接地改变值, 使得缓存不准确.</p>

<h3>相关</h3>
<ul>
  <li><a href="Variables.htm#Intro">变量</a>: 基本用法和示例.</li>
  <li><a href="Variables.htm#cap">变量的容量和内存占用</a>: 有关限制的详细信息.</li>
</ul>

<h2 id="functions">函数/命令</h2>
<p><em>函数</em> 或 <em>命令</em> 是脚本 <em>执行某些操作</em> 的基本手段.</p>
<p>实质上, 函数和命令是一回事, 所以这里解释的概念适用于两者. 然而, AutoHotkey v1 的悠久历史和强化向后兼容性, 导致了需要传统语法的 <em>命令</em> 和需要表达式语法的<em>函数</em> 之间的差异.</p>
<p>命令和函数可以有很多不同的目的. 一些函数可能只是执行一个简单的计算, 而另一些可以立即看到效果, 比如移动一个窗口. AutoHotkey 的优势之一就是脚本可以轻松地自动执行其他程序, 并通过简单地调用几个函数执行许多其他常见任务. 有关示例, 请参阅 <a href="commands/index.htm">命令和函数列表</a>.</p>
<p>在整篇文档中, 一些常见的词汇的使用方式对于没有经验的人来说可能并不是通俗易懂的.下面是一些与函数和命令相关的常用单词/短语:</p>
<dl>
  <dt id="call">调用函数或命令 <dd>
  <p><em>调用</em> 函数或命令会导致程序调用, 执行或计算它. 换句话说, <em>函数调用</em> 暂时将控制权从脚本转移到函数. 函数完成其目的时, 它将控制权 <em>返回</em> 给脚本. 换句话说, 函数调用之后的任何代码都不会执行, 直到函数完成.</p>
  <p>但是, 有时一个函数或命令可以在用户看到它的效果之前完成. 例如, <a href="commands/Send.htm">Send</a> 命令 <em>sends</em> 键击, 但可能会在键击到达其目的地并返回其预期效果之前返回.</p>
  <dt id="parameters">参数<dd>
  <p>通常一个命令或函数接受 <em>参数</em>, 告诉它如何操作或操作什么. 每个参数都是一个 <a href="#values">值</a>, 如字符串或数字. 例如, <a href="commands/WinMove.htm">WinMove</a> 移动一个窗口, 所以它的参数告诉它要移动哪个窗口以及移动到哪里. Parameter(参数) 也可以被称为 <em>arguments(参数)</em>. 常用的缩写包括 <em>param</em> 和 <em>arg</em>.</p>
  <dt id="pass-parameters">传递参数<dd>
  <p>Parameters are <em>passed</em> to a function or command, meaning that a value is specified for each parameter of the function or command when it is called. For example, one can <em>pass</em> the name of a key to <a href="commands/GetKeyState.htm">GetKeyState</a> to determine whether that key is being held down.</p>
  <dt id="return-a-value">返回值<dd>
  <p>Functions <em>return</em> a value, so the result of the function is often called a <em>return value</em>. For example, <a href="commands/StringLen.htm">StrLen</a> returns the number of characters in a string. Commands do not return a result directly; instead, they store the result in a <a href="#variables">variable</a>. Functions may also do this, such as when there is more than one result.</p>
</dl>
<p>Functions and commands usually expect parameters to be written in a specific order, so the meaning of each parameter value depends on its position in the comma-delimited list of parameters. Some parameters can be omitted, in which case the parameter can be left blank, but the comma following it can only be omitted if all remaining parameters are also omitted. For example, the syntax for <a href="commands/ControlSend.htm">ControlSend</a> is:</p>
<pre>ControlSend [, Control, Keys, WinTitle, WinText, ExcludeTitle, ExcludeText]
</pre>
<p>Square brackets signify that the enclosed parameters are optional (the brackets themselves should not appear in the actual code). However, ControlSend isn't useful unless <em>Keys</em> are specified, and usually one must also specify the target window. For example:</p>
<pre>ControlSend, Edit1, ^{Home}, A  <em>; Correct. Control is specified.</em>
ControlSend, ^{Home}, A         <em>; Incorrect: Parameters are mismatched.</em>
ControlSend,, ^{Home}, A        <em>; Correct. Control is omitted.</em>
</pre>

<h3 id="methods">方法</h3>
<p><em>Methods</em> are functions which operate on a particular <a href="#objects">object</a>. While there can only be one function named <code>Send</code> (for example), there can be as many methods named <code>Send</code> as there are objects, as each object (or class of objects) can respond in a different way. For this reason, the target object (which may be a variable or sub-expression) is specified to left of the method name instead of inside the parameter list. For details, see <a href="#object-protocol">Object Protocol</a>.</p>

<h2 id="control-flow">控制流</h2>
<p><em>Control flow</em> is the order in which individual statements are executed. Normally statements are executed sequentially from top to bottom, but a control flow statement can override this, such as by specifying that statements should be executed repeatedly, or only if a certain condition is met.</p>
<dl>
  <dt id="statement">Statement <dd>
  <p>A <em>statement</em> is simply the smallest standalone element of the language that expresses some action to be carried out. In AutoHotkey, statements include commands, assignments, function calls and other expressions. However, directives, labels (including hotkeys and hotstrings), and declarations without assignments are not statements; they are processed when the program first starts up, before the script <em>executes</em>.</p>
  <dt id="execute">Execute <dd>
  <p>Carry out, perform, evaluate, put into effect, etc. <em>Execute</em> basically has the same meaning as in non-programming speak.</p>
  <dt id="body">Body <dd>
  <p>The <em>body</em> of a control flow statement is the statement or group of statements to which it applies. For example, the body of an <a href="Language.htm#if-statement">if statement</a> is executed only if a specific condition is met.</p>
</dl>
<p>For example, consider this simple set of instructions:</p>
<ol>
  <li>Open Notepad</li>
  <li>Wait for Notepad to appear on the screen</li>
  <li>Type &quot;Hello, world!&quot;</li>
</ol>
<p>We take one step at a time, and when that step is finished, we move on to the next step. In the same way, control in a program or script usually flows from one statement to the next statement. But what if we want to type into an existing Notepad window? Consider this revised set of instructions:</p>
<ol>
  <li>If Notepad is not running:
<ol>
  <li>Open Notepad</li>
  <li>Wait for Notepad to appear on the screen</li>
</ol>
</li>
  <li>Otherwise:
<ol>
  <li>Activate Notepad</li>
</ol>
</li>
  <li>Type &quot;Hello, world!&quot;</li>
</ol>
<p>So we either open Notepad or activate Notepad depending on whether it is already running. #1 is a <em>conditional statement</em>, also known as an <em>if statement</em>; that is, we execute its <em>body</em> (#1.1 - #1.2) only if a condition is met. #2 is an <em>else statement</em>; we execute its body (#2.1) only if the condition of a previous <em>if statement</em> (#1) is not met. Depending on the condition, control <em>flows</em> one of two ways: #1 (if true) &rarr; #1.1 &rarr; #1.2 &rarr; #3; or #1 (if false) &rarr; #2 (else) &rarr; #2.1 &rarr; #3.</p>
<p>The instructions above can be translated into the code below:</p>
<pre>if (not WinExist(&quot;ahk_class Notepad&quot;))
{
    Run Notepad
    WinWait ahk_class Notepad
}
else
    WinActivate ahk_class Notepad
Send Hello`, world!
</pre>
<p>In our written instructions, we used indentation and numbering to group the statements. Scripts work a little differently. Although indentation makes code easier to read, in AutoHotkey it does not affect the grouping of statements. Instead, statements are grouped by enclosing them in braces, as shown above. This is called a <a href="commands/Block.htm"><em>block</em></a>.</p>
<p class="note">For details about syntax - that is, how to write or recognise control flow statements in AutoHotkey - see <a href="Language.htm#control-flow">Control Flow</a>.</p>

<h2 id="details">细节</h2>

<h3 id="string-encoding">字符编码</h3>
<p>Each character in the string is represented by a number, called its <em>ordinal number</em>, or <em>character code</em>. For example, the value &quot;Abc&quot; would be represented as follows:</p>
<table class="info" style="width: 8em; text-align: center">
  <tr><td>A<td>b<td>c
  <tr><td>65<td>98<td>99
</table>
<p>The <em>encoding</em> of a string is the way in which numbers are mapped to symbols. There are many different encodings, but as all of those supported by AutoHotkey include ASCII as a subset, character codes 0 to 127 always have the same meaning. For example, 'A' always has the character code 65.</p>
<p>Although AutoHotkey provides ways to work with text in various encodings, the built-in commands and functions--and to some degree the language itself--all assume string values to be in one particular encoding. This is referred to as the <em>native</em> encoding. The native encoding depends on the version of AutoHotkey:</p>
<ul>
  <li>
<p>Unicode versions of AutoHotkey use UTF-16. The smallest element in a UTF-16 string is two bytes (16 bits). Unicode characters in the range 0 to 65535 (U+FFFF) are represented by a single 16-bit code unit of the same value, while characters in the range 65536 (U+10000) to 1114111 (U+10FFFF) are represented by a <em>surrogate pair</em>; that is, exactly two 16-bit code units between 0xD800 and 0xDFFF. (For further explanation of surrogate pairs and methods of encoding or decoding them, search the Internet.)</p>
</li>
  <li>
<p>ANSI versions of AutoHotkey use the system default ANSI code page, which depends on the system locale or &quot;language for non-Unicode programs&quot; system setting. The smallest element of an ANSI string is one byte. However, some code pages contain characters which are represented by sequences of multiple bytes (these are always non-ASCII characters).</p>
</li>
</ul>
<p>Generally, other parts of this documentation use the term &quot;character&quot; to mean a string's smallest unit; bytes for ANSI strings and 16-bit code units for Unicode strings. For practical reasons, the length of a string and positions within a string are measured by counting these fixed-size units, even though they may not be complete Unicode characters.</p>
<p><a href="commands/FileRead.htm">FileRead</a>, <a href="commands/FileAppend.htm">FileAppend</a>, <a href="commands/FileOpen.htm">FileOpen</a> and the <a href="objects/File.htm">File object</a> provide ways of reading and writing text in files with a specific encoding.</p>
<p>The functions <a href="commands/StrPutGet.htm">StrGet and StrPut</a> can be used to convert strings between the native encoding and some other specified encoding. However, these are usually only useful in combination with data structures and the <a href="commands/DllCall.htm">DllCall</a> function. Strings which are passed directly to or from <a href="commands/DllCall.htm">DllCall</a> can be converted to ANSI or UTF-16 by using the <code>AStr</code> or <code>WStr</code> parameter types.</p>
<p>Techniques for dealing with the differences between ANSI and Unicode versions of AutoHotkey can be found under <a href="Compat.htm#Format">Unicode vs ANSI</a>.</p>

<h3 id="pure-numbers">纯数字</h3>
<p><em>纯</em>数字 或 <em>二进制</em>数字 是以计算机的 CPU 可以直接使用的格式(例如执行数学运算) 存储在内存中的数字. 在大多数情况下, AutoHotkey 会自动根据需要在数字字符串和纯数字之间进行转换, 很少区分这两种类型. AutoHotkey 主要为纯数字使用两种数据类型:</p>
<ul>
  <li>64 位有符号整数(<em>int64</em>).</li>
  <li>64 位二进制浮点数(IEEE 754 国际标准的 <em>double</em> 或 <em>binary64</em> 格式).</li>
</ul>
<p>换句话说, 脚本受以下限制的影响:</p>
<ul>
  <li>
<p>整数必须在 -9223372036854775808 (-0x8000000000000000, 或 -2<sup>63</sup>) 到 9223372036854775807 (0x7FFFFFFFFFFFFFFF, 或 2<sup>63</sup>-1). 尽管字符串中可以包含更大的值, 但是将字符串转换为数字(例如在数学运算中使用该字符串)  的尝试可能会产生不一致的结果.</p>
</li>
  <li>
<p>Floating-point numbers generally support 15 digits of precision. However, converting a floating-point number to a string causes the number to be rounded according to the current <a href="commands/SetFormat.htm#Float">float format</a>, which defaults to 6 decimal places. If the &quot;slow&quot; mode of <a href="commands/SetFormat.htm">SetFormat</a> is present anywhere in the script, numbers are <em>always</em> converted to strings when assigned to a <a href="#variables">variable</a>.</p>
</li>
</ul>
<p><strong>Note:</strong> There are some decimal fractions which the binary floating-point format cannot precisely represent, so a number is rounded to the closest representable number. This may lead to unexpected results. For example:</p>
<pre>SetFormat FloatFast, 0.17  <em>; Show &quot;over-full&quot; precision</em>
MsgBox % 0.1 + 0           <em>; 0.10000000000000001</em>
MsgBox % 0.1 + 0.2         <em>; 0.30000000000000004</em>
MsgBox % 0.3 + 0           <em>; 0.29999999999999999</em>
MsgBox % 0.1 + 0.2 = 0.3   <em>; 0 (not equal)</em>
</pre>
<p>One strategy for dealing with this is to avoid direct comparison, instead comparing the difference. For example:</p>
<pre>MsgBox % Abs((0.1 + 0.2) - (0.3)) &lt; 0.0000000000000001
</pre>
<p>Another strategy is to always convert to string (thereby applying rounding) before comparison. There are generally two ways to do this while specifying the precision, and both are shown below:</p>
<pre>MsgBox % Round(0.1 + 0.2, 15) = Format(&quot;{:.15f}&quot;, 0.3)
</pre>

<h3 id="names">名称</h3>
<p>AutoHotkey uses the same set of rules for naming various things, including variables, functions, <a href="commands/GroupAdd.htm">window groups</a>, <a href="commands/Gui.htm">GUIs</a>, classes and methods:</p>
<ul>
  <li><strong>Case sensitivity:</strong> None for ASCII characters. For example, <code>CurrentDate</code> is the same as <code>currentdate</code>. However, uppercase non-ASCII characters such as '?' are <em>not</em> considered equal to their lowercase counterparts, regardless of the current user's locale. This helps the script to behave consistently across multiple locales.</li>
  <li><strong>Maximum length:</strong> 253 characters.</li>
  <li><strong>Allowed characters:</strong> Letters, numbers, non-ASCII characters, and the following symbols: _ # @ $</li>
</ul>
<p>Due to style conventions, it is generally better to name your variables using only letters, numbers, and the underscore character (for example: <em>CursorPosition</em>, <em>Total_Items</em>, and <em>entry_is_valid</em>). This style allows people familiar with other computer languages to understand your scripts more easily.</p>
<p>Although a <a href="#variables">variable</a> name may consist entirely of digits, this is generally used only for <a href="Scripts.htm#cmd_args_old">incoming command line parameters</a>. Such numeric names cannot be used in expressions because they would be seen as numbers rather than variables. It is best to avoid starting a name with a digit, as such names are confusing and will be considered invalid in AutoHotkey v2.</p>
<p>As the following characters may be reserved for other purposes in AutoHotkey v2, it is recommended to avoid using them: # @ $</p>
<p>Property names in classes have the same rules and restrictions as variable names, except that the three characters listed above (# @ $) are not allowed. Although they can be used in a method definition, calling such a method requires using square brackets. For example, <code>myObject.@home()</code> is not valid, but <code>myObject[&quot;@home&quot;]()</code> is acceptable.</p>

<h3 id="variable-references">变量引用与值</h3>
<p>Variables have certain attributes that blur the line between a variable and its value, but it is important to make the distinction. In particular, consider <a href="#objects">objects</a> and ByRef parameters.</p>
<p>Although we may say the variable <code>myArray</code> <em>contains</em> an array (which is a type of object), what the variable contains isn't the array itself but rather a <em>reference or pointer</em> to the array. Any number of variables can contain a reference to the same object. It may be helpful to think of a variable as just a name in that case. For instance, giving a person a nickname doesn't cause a clone of that person to come into existence.</p>
<p>By default, variables are passed to user-defined functions <em>by value</em>. In other words, the value contained by the variable is copied into the variable which corresponds to the function's parameter. <strong>ByRef</strong> parameters allow you to pass a variable <em>by reference</em>, or in other words, to make one parameter of the function an <em>alias</em> for your variable, allowing the function to assign a new value to your variable.</p>
<p>Because a variable only ever contains a <em>reference</em> to an object and not the object itself, when you pass such a variable to a non-ByRef parameter, what the function receives is a reference to the same object. This allows the function to modify the object, but it does not allow the function to modify the <em>variable</em> which the function's caller used, because the function only has a reference to the object, not the variable.</p>

<h3 id="references-to-objects">对象的引用</h3>
<p>Scripts interact with an object only indirectly, through a <em>reference</em> to the object. When you create an object, the object is created at some location you don't control, and you're given a reference. Passing this reference to a function or storing it in a variable or another object creates a new reference to the <em>same</em> object. You release a reference by simply using an assignment to replace it with any other value. An object is deleted only after all references have been released; you cannot delete an object explicitly, and should not try.</p>
<pre>ref1 := Object()  <em>; Create an object and store first reference</em>
ref2 := ref1      <em>; Create a new reference to the same object</em>
ref1 := &quot;&quot;        <em>; Release the first reference</em>
ref2 := &quot;&quot;        <em>; Release the second reference; object is deleted</em>
</pre>
<p>If that's difficult to understand, try thinking of an object as a rental unit. When you rent a unit, you're given a key which you can use to access the unit. You can get more keys and use them to access the same unit, but when you're finished with the unit, you must hand all keys back to the rental agent. Usually a unit wouldn't be <em>deleted</em>, but maybe the agent will have any junk you left behind removed; just as any values you stored in an object are freed when the object is deleted.</p>

</body>
</html>