<!DOCTYPE HTML>
<html>
<head>
<title>脚本语言</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<link href="static/theme.css" rel="stylesheet" type="text/css" />
<script src="static/content.js" type="text/javascript"></script>
</head>
<body>
<h1>脚本语言</h1>
<p>一个 AutoHotkey 脚本从根本上说是使用 AutoHotkey 独有的自定义语言编写的程序要遵循的指令集合. 这种语言与其他几种脚本语言有一些相似之处, 但也有其独特的优势和缺陷. 本文档描述了该语言, 并试图指出常见的缺陷.</p>
<p class="note">有关 AutoHotkey 所使用的各种概念的更一般的解释, 请参阅 <a href="Concepts.htm">概念和约定</a>.</p>
<p class="warning">在 AutoHotkey 中使用两种不同的语法样式: <a href="#legacy-syntax">传统语法</a> 和 <a href="#expressions">表达式</a>.</p>

<h2>目录</h2>
<ul>
  <li><a href="#general-conventions">常规约定</a></li>
  <li><a href="#comments">注释</a></li>
  <li><a href="#expressions">表达式</a>
  <ul>
    <li><a href="#strings">字符串 / 文本</a></li>
    <li><a href="#variables">变量</a></li>
    <li><a href="#operators">运算符</a></li>
    <li><a href="#function-calls">函数调用</a></li>
    <li><a href="#operators-for-objects">对象的运算符</a></li>
    <li><a href="#expression-statements">表达式语句</a></li>
  </ul></li>
  <li><a href="#legacy-syntax">传统语法</a></li>
  <li><a href="#commands">命令</a>
  <ul>
    <li><a href="#outputvar-and-inputvar-parameters">OutputVar 和 InputVar 参数</a></li>
    <li><a href="#text-parameters">文本参数</a></li>
    <li><a href="#numeric-parameters">数字参数</a></li>
    <li><a href="#-expression">% 表达式</a></li>
    <li><a href="#documentation-conventions">文档约定</a></li>
    <li><a href="#optional-parameters">可选参数</a></li>
  </ul></li>
  <li><a href="#expressions-vs-legacy-syntax">表达式与传统语法</a>
  <ul>
    <li><a href="#different-equals">不同的等号</a></li>
    <li><a href="#commands-vs-functions">命令与函数</a></li>
  </ul></li>
  <li><a href="#control-flow">控制流语句</a>
  <ul>
    <li><a href="#control-flow-vs-commands">控制流与命令</a></li>
    <li><a href="#if-statement">If 语句</a></li>
    <li><a href="#loop-statement">Loop 语句</a></li>
    <li><a href="#not-control-flow">非控制流</a></li>
  </ul></li>
  <li><a href="#structure-of-a-script">脚本的结构</a>
  <ul>
    <li><a href="#auto-execute-section">自动执行部分</a></li>
    <li><a href="#subroutines">子程序</a></li>
    <li><a href="#user-defined-functions">用户定义的函数</a></li>
    <li><a href="#-include">#Include</a></li>
  </ul></li>
  <li><a href="#misc">杂项</a>
  <ul>
    <li><a href="#dynamic-variables">动态变量</a>
    <ul>
      <li><a href="#pseudo-arrays">伪数组</a></li>
      <li><a href="#associative-pseudo-arrays">关联伪数组</a></li>
      <li><a href="#commands-which-create-pseudo-arrays">创建伪数组的命令</a></li>
    </ul></li>
    <li><a href="#labels">标签</a></li>
  </ul></li>
</ul>
<!-- TODO:
Directives
Declarations
Class definitions
Methods?
-->

<h2 id="general-conventions">常规约定</h2>
<p><strong>名称:</strong> 变量和函数名称不区分大小写 (例如, <code>CurrentDate</code> 和 <code>currentdate</code> 是一样的). 有关最大长度和可用字符等详细信息, 请参阅 <a href="Concepts.htm#names">Names(名称)</a>.</p>
<p><strong>无类型变量:</strong> 变量没有明确定义的类型; 相反, 任何类型的值都可以存储在任何变量中(不包括内置变量). 数字可能会自动转换为字符串(文本), 反之亦然, 这取决于实际情况.</p>
<p><strong>声明是可选的:</strong> 除了在 <a href="Functions.htm">函数页面</a> 上注明的地方外, 不需要声明变量; 它们的存在仅仅是通过使用它们(每个变量都是从空/空白开始的).</p>
<p><strong>空格通常被忽略:</strong> 缩进(前导空格) 对于编写可读代码非常重要, 但是程序不需要, 通常会被忽略.  <em>通常</em> 在行尾的, 表达式内的(引号之间的除外), 以及命令参数之前和之后的空格和制表符会被忽略. 然而, 在一些情况下, 空格是重要的, 包括:</p>
<ul>
  <li><a href="#function-calls">函数</a> 和 方法调用要求在函数/方法 名称和 <code>(</code> 之间没有空格.</li>
  <li>连接时需要空格.</li>
  <li>两个运算符之间可能需要空格, 以消除歧义.</li>
  <li>单行 <a href="#comments">注释</a> 如果不在行首, 则需要前导空格.</li>
</ul>
<p><strong>换行符是有意义的:</strong> 换行符通常作为语句分隔符, 终止以前的命令或表达式.(<em>语句</em> 只是表示要执行的某个操作的语言中最小的独立元素.) 这个例外是 <a href="Scripts.htm#continuation">行延续</a>, 它通过预处理工作; 也就是说, 它是在其他语言元素之前处理的, 而且是独立于其他语言元素的.</p>
<p><strong>行延续:</strong> 长行可以分成一些小行, 以提高可读性和可维护性. 这是通过预处理实现的, 所以不属于这种语言的一部分. 有两种方法:</p>
<ul>
  <li><a href="Scripts.htm#continuation-line">行延续</a>, 其中以 <a href="Variables.htm#operators">表达式运算符</a>(++ 和 -- 除外) 开始的行与前一行合并. 行被合并, 而不管该行是否实际包含表达式.</li>
  <li><a href="Scripts.htm#continuation-section">延续片段</a>, 其中多行与片段上方的行合并. 延续片段的开始和结尾标有 <code>(</code> 和 <code>)</code>(两个符号必须出现在行的开头, 不包括空格).</li>
</ul>
 

<h2 id="comments">注释</h2>
<p><em>注释</em> 是脚本中被程序忽略的部分文本. 它们通常用于添加解释或禁用部分代码.</p>
<p>在行首使用分号可以注释当前行脚本. 例如:</p>
<pre><em>; 这整行是注释.</em></pre>
<p>也可以在命令的末尾添加注释, 此时分号左侧必须至少有一个空格或 tab. 例如:</p>
<pre>Run Notepad  <em>; 这是和命令在同一行的注释.</em></pre>
<p>此外, 可以使用 <code><em>/*</em></code> 和 <code><em>*/</em></code> 符号注释整块代码, <em>但仅当它们出现在行首时才有效</em> 如下例所示:</p>
<pre><em>/*
MsgBox, 这行被注释掉了(禁用).
MsgBox, 常见的错误: */ 这不会结束注释.
MsgBox, 这行被注释掉了. 
*/</em>
</pre>
<p>由于脚本运行时会忽略注释, 所以它们不会影响脚本性能或占用内存.</p>
<p>使用 <a href="commands/_CommentFlag.htm">#CommentFlag</a> 可以把默认的注释符号(分号) 改为其他字符或字符串.</p>

<h2 id="expressions">表达式</h2>
<p><strong><em>表达式</em></strong> 是一个或多个 <a href="Concepts.htm#values">值</a>, <a href="Concepts.htm#variables">变量</a>, <a href="#operators">运算符</a> 和 <a href="#function-calls">函数调用</a> 的组合. 例如, <code>10</code>, <code>1+1</code> 和 <code>MyVar</code> 是有效的表达式. 通常, 表达式将一个或多个值作为输入, 执行一个或多个操作, 并生成一个值作为结果. 找出表达式值的过程被称为 <em>计算</em>. 例如, 表达式 <code>1+1</code> <em>计算</em> 结果为数字 2.</p>
<p><a href="#commands">命令</a> 的目的是获取参数列表, 每行只执行一个动作, 而简单的表达式可以拼凑在一起形成越来越复杂的表达式. 例如, 如果 <code>Discount/100</code> 将折扣百分比转换为分数, <code>1 - Discount/100</code> 计算剩余金额的分数, 而 <code>Price * (1 - Discount/100)</code> 应用它来产生净价格.(译者注: 英语和汉语在打折的说法上一般是相反的, 10% off, discount prices at 10% 表示打九折.)</p>
<p><em>值</em> 是 <a href="Concepts.htm#numbers">数字</a>, <a href="Concepts.htm#objects">对象</a> 或 <a href="Concepts.htm#strings">字符串</a>. <em>字面</em> 值是在脚本中写入的值; 当您在查看代码时可以看到该值.</p>

<h3 id="strings">字符串 / 文本</h3>
<p class="note">有关字符串的更一般的解释, 请参阅 <a href="Concepts.htm#strings">字符串</a>.</p>
<p><em>字符串</em> 或 <em>字符组成的串</em>, 只是一个文本值. 在表达式中, 原义的文本必须用引号引起来, 以区分变量名称或其他表达式. 这通常被称为 <em>加引号的原义字符串</em>, 或者为 <em>加引号的字符串</em>. 例如, <code>&quot;This is a quoted string.&quot;</code>.</p>
<p>要在原义字符串中包含 <em>真实的</em> 引号字符, 请指定两个连续的引号, 如下面例子中的演示: <code>&quot;她说, &quot;&quot;一个苹果一天.&quot;&quot;&quot;</code>.</p>
<p>加引号的字符串能包含 <a href="commands/_EscapeChar.htm">转义序列</a> 例如 <code>`t</code>(tab 制表符), <code>`n</code>(换行) 和 <code>`r</code>(回车). 与 <a href="#unquoted-text">不加引号的字符串</a> 不同的是, 不需要转义逗号或百分号, 因为加引号的字符串不能包含变量. 现在不支持使用 <code>`&quot;</code> 转义序列来产生原义的引号字符; 而是使用两个连续的引号, 如上所示.</p>

<h3 id="variables">变量</h3>
<p class="note">有关变量的基本解释和一般细节, 请参阅 <a href="Concepts.htm#variables">变量</a>.</p>
<p><em>变量</em> 可以简单地通过写变量名来用于表达式. 例如, <code>A_ScreenWidth/2</code>. 但是, 变量不能在加引号的字符串中使用. 作为替代, 变量和其他值可以通过名为 <a href="Variables.htm#concat"><em>连接</em></a> 的过程与文本组合起来. 有两种方法能用于 <em>连接</em> 表达式中的值:</p>
<ul>
  <li>隐式连接: <code>&quot;The value is &quot; MyVar</code></li>
  <li>显示连接: <code>&quot;The value is &quot; . MyVar</code></li>
</ul>
<p>隐式连接也被称为 <em>自动连接</em>. 在这两种情况下, 变量和点之前的空格都是必需的.</p>
<p>The <a href="commands/Format.htm">Format</a> 函数也可以用于此目的. 例如:</p>
<pre>MsgBox % Format(&quot;You are using AutoHotkey v{1} {2}-bit.&quot;, A_AhkVersion, A_PtrSize*8)
</pre>
<p>要为变量赋值, 请使用 <code>:=</code> <a href="Variables.htm#AssignOp">赋值运算符</a>, 如 <code>MyVar := &quot;Some text&quot;</code>.</p>
<p>表达式中的 <em>百分号</em> 用于创建 <a href="#dynamic-variables">动态变量引用</a> 和 <a href="Functions.htm#DynCall">动态函数调用</a>. 大多数情况下, 这些结构是不需要的, 所以一般来说, 变量名不应该包含在表达式的百分号中.</p>

<h3 id="operators">运算符</h3>
<p><em>运算符</em> 用符号或符号组的形式, 如 <code>+</code> 或 <code>:=</code>, 或者其中一个单词 <code>and</code>, <code>or</code>, <code>not</code> 或 <code>new</code>. 他们将一个, 两个或三个值作为输入, 并返回一个值作为结果. 用作运算输入的值或子表达式称为 <em>运算元</em>.</p>
<ul>
  <li><em>一元</em> 运算符可以写在单个运算元之前或之后, 体取决于运算符. 例如, <code>-x</code> 或 <code>not keyIsDown</code>.</li>
  <li><em>二元</em> 运算符写在两个运算元之间. 例如, <code>1+1</code> 或 <code>2 * 5</code>.</li>
  <li>AutoHotkey 只有一个 <em>三元</em> 运算符, 它采用如下的形式 <a href="Variables.htm#ternary"><code>condition(条件) ? valueIfTrue(条件为真时的值) : valueIfFalse(条件为假时的值)</code></a>.</li>
</ul>
<p>一些一元和二元运算符共享相同的符号, 在这种情况下,  运算符的含义取决于它是写在两个值之前, 之后还是之间. 例如, <code>x-y</code> 执行减法, 而 <code>-x</code> 反转 <code>x</code> 的符号(从负值产生正值, 反之亦然).</p>
<p>除非在 <a href="Variables.htm#Expression_Operators_in_descending_precedence_order">运算符表</a> 中另有规定, 否则相同优先级的运算符(例如乘(<code>*</code>) 和除(<code>/</code>)) 将按从左到右的顺序进行计算. 相反, 诸如加(<code>+</code>) 之类的较低优先级的运算符在诸如乘(<code>*</code>) 之类的较高运算符之后被计算. 例如, <code>3 + 2 * 2</code> 作为 <code>3 + (2 * 2)</code> 计算. 括号可以用来覆盖优先级, 如以下示例所示: <code>(3 + 2) * 2</code></p>

<h3 id="function-calls">函数调用</h3>
<p class="note">有关函数和相关术语的一般解释, 请参阅 <a href="Concepts.htm#functions">函数/命令</a>.</p>
<p><em>函数</em> 需要可变化数量的输入, 去执行一些动作或计算, 然后 <a href="Concepts.htm#return-a-value"><em>返回</em></a> 一个结果. 函数的输入被称为 <a href="Concepts.htm#parameters"><em>parameters(参数)</em></a> 或 <em>arguments(参数)</em>. 一个函数被简单地通过写它的名字, 后跟着用括号括起来的参数来 <a href="Concepts.htm#call"><em>调用</em></a>. 例如, 如果 Shift 键被按下, 则 <code>GetKeyState(&quot;Shift&quot;)</code> 返回(计算出) 1, 否则返回 0.</p>
<p class="warning"><strong>注意:</strong> 函数名和左括号之间不能有空格.
</p>
<p>与 <a href="#commands">命令</a> 相比, 括号的要求起初可能看起来含糊不清或冗长, 但是它们允许将函数调用与其他操作结合起来. 例如, 只有当两个键被物理按下时, 表达式 <code>GetKeyState(&quot;Shift&quot;, &quot;P&quot;) and GetKeyState(&quot;Ctrl&quot;, &quot;P&quot;)</code> 才会返回 1.</p>
<p>函数名称始终是全局的, 并且与变量名称是分开的. 例如, <code>Round</code> 可以同时是一个变量名和一个函数名, 然而 <code>Round := 1</code> 不会以任何方式影响 <code>Round(n)</code>.</p>

<h3 id="operators-for-objects">对象的运算符</h3>
<p>这里表达式中使用的其他符号不完全符合上面定义的任何类别，或影响表达式其他部分的含义, 如下所述. 这些都以某种方式与 <em>对象</em> 有关. 对于每个构造所做的事情提供一个完整的解释，需要引入更多的概念, 而这不属于本节的范围.</p>
<p><code>Alpha.Beta</code> 通常称为 <em>成员访问</em>. <em>Alpha</em> 是一个普通变量, 可以用函数调用或其他一些其他返回对象的子表达式替换. 当计算时, 对象发送一个请求 &quot;给我属性 <em>Beta</em> 的值&quot;, &quot;在属性 <em>Beta</em> 中存储这个值&quot; 或 &quot;调用名为 <em>Beta</em> 的方法&quot;. 换句话说, <em>Beta</em> 是一个对对象有意义的名字; 它不是一个局部或全局变量.</p>
<p><code>Alpha.Beta()</code> 是一个 <em>方法调用</em>, 如上所述.</p>
<p><code>Alpha.Beta[Param]</code> 是成员访问的一种特殊形式, 其中包括了请求中的附加参数. <em>Beta</em> 只是一个简单的名称, 但 <em>Param</em> 是一个普通的变量或子表达式, 或者是由逗号分隔的子表达式列表(与函数的参数列表中相同).</p>
<p><code>Alpha[Index]</code> 具有与 <code>Alpha.Beta</code> 类似的功能, 但每个部分都以更加标准的方式进行解释. 也就是说, 在这种情况下, <em>Alpha</em> 和 <em>Index</em> 都是变量, 实际上可以用任何子表达式替换. 此语法通常用于检索 <a href="Objects.htm#Usage_Simple_Arrays">数组</a> 或 <a href="Objects.htm#Usage_Associative_Arrays">关联数组</a> 中的元素.</p>
<p><code>new ClassName()</code> 用于实例化一个类, 或者创建一个从另一个对象派生的对象. 虽然这看起来像一个函数调用, 但 <em>ClassName</em> 实际上是一个普通的变量. 同样, <code>new Alpha.Beta()</code>将创建一个从 <code>Alpha.Beta</code> 返回的对象派生的对象; <em>Beta</em> 既不是函数也不是方法. 如果存在可选的括号, 则可能包含对象的 <a href="Objects.htm#Custom_NewDelete">__New</a> 方法的参数.</p>
<p><code>[A, B, C]</code> 创建一个初始内容为 A, B 和 C(本例中的所有变量) 的 <a href="Objects.htm#Usage_Simple_Arrays">数组</a>, 其中 A 是元素 1.</p>
<p><code>{Key1: Value1, Key2: Value2}</code> 从键值对列表中创建一个 <a href="Objects.htm#Usage_Associative_Arrays">关联数组</a>.以后值可以通过其关联的键来检索. 在 <code>:</code> 左侧写入一个简单的单词(由字母数字字符, 下划线和非 ASCII 字符组成) 等同于将该单词括在引号中. 例如, <code>{A: B}</code> 等同于 <code>{&quot;A&quot;: B}</code>. 但是, <code>{(A): B}</code> 使用变量 <code>A</code> 的内容作为键.</p>
<p><code>MyFunc(Params*)</code> 是一个 <a href="Functions.htm#VariadicCall">可变函数调用</a>. 星号必须紧跟在函数参数列表末尾的右括号之前. <em>参数</em> 必须是返回数组对象的变量或子表达式. 尽管在任何地方使用 <code>Params*</code> 都是无效的, 但它可以用在数组文字(<code>[A, B, C, ArrayToAppend*]</code>) 或索引器(<code>Alpha[Params*]</code>) 中.</p>

<h3 id="expression-statements">表达式语句</h3>
<p>并不是所有的表达式都可以单独在一行上使用. 例如, 只包含 <code>21*2</code> 或 <code>&quot;Some text&quot;</code> 的行就没有任何意义. 表达式 <em>语句</em> is an expression used on its own, typically for its side-effects. Most expressions with side-effects can be used this way, so it is generally not necessary to memorise the details of this section.</p>
<p>以下类型的表达式可以用作语句:</p>
<p>赋值, 如 <code>x := y</code>, compound assignments such as <code>x += y</code>, and increment/decrement operators such as <code>++x</code> and <code>x--</code>. However, in AutoHotkey v1, <code>++</code>, <code>--</code>, <code>+=</code>, <code>-=</code>, <code>*=</code> and <code>/=</code> have slightly different behavior when used alone on a line, as they are actually equivalent to EnvAdd, EnvSub, EnvMult or EnvDiv. For details, see &quot;Known limitations&quot; under <a href="Variables.htm#AssignOp">Assign</a> in the table of operators.</p>
<p>函数调用, 如 <code>MyFunc(Params)</code>. 但是, a standalone function call cannot be followed by an open brace <code>{</code> (at the end of the line or on the next line), because it would be confused with a function declaration.</p>
<p>方法调用, 如 <code>MyObj.MyMethod()</code>.</p>
<p>Member access using square brackets, such as <code>MyObj[Index]</code>, which can have side-effects like a function call.</p>
<p>Expressions starting with the <code>new</code> operator, as in <code>new ClassName</code>, because sometimes a class can be instantiated just for its side-effects.</p>
<p>Ternary expressions such as <code>x ? CallIfTrue() : CallIfFalse()</code>. However, in AutoHotkey v1, command names take precedence. 例如, <code>MsgBox ? 1 : 0</code> shows a message box.</p>
<p>Expressions starting with <code>(</code>. However, there usually must be a matching <code>)</code> on the same line, otherwise the line would be interpreted as the start of a <a href="Scripts.htm#continuation">continuation section</a>.</p>
<p>Expressions that start with any of those described above (but not those described below) are also allowed, for simplicity. 例如, <code>MyFunc()+1</code> is currently allowed, although the <code>+1</code> has no effect and its result is discarded. Such expressions might become invalid in the future due to enhanced error-checking.</p>
<p>Member access using a dot (once or in a series), such as <code>ExcelApp.Quit</code> or <code>x.y.z</code>. However, unless parentheses are used (as in a method call), this cannot be the prefix of a larger expression. 例如, <code>ExcelApp.Quit, xxx</code> is prohibited due to the apparent similarity to command syntax.</p>

<h2 id="legacy-syntax">传统语法</h2>
<p><em><strong>Legacy</strong></em> or <em><strong>command</strong></em> syntax generally only allows a single action per line, but uses fewer characters to perform simple tasks such as <a href="commands/Send.htm">sending keystrokes</a> or <a href="commands/Run.htm">running a program</a>. The syntax consists of command and variable names, <em>unquoted text</em> and a few symbols such as <code>,</code>, <code>=</code> and <code>%</code>.</p>
<p id="unquoted-text"><em>Unquoted text</em> is simply text, not enclosed in quote marks, just straight up. Since the text has no explicit start and end marks, it ends at the end of the line or the end of the parameter. Leading and trailing spaces and tabs are ignored. Within unquoted text, the following characters have special meaning:</p>
<ul>
  <li>
<p><code>%</code>: Enclose a variable name in percent signs to include the contents of that variable. 例如, <code>The year is %A_Year%.</code></p>
<p class="warning"><strong>Note:</strong> Variable names are not <em>always</em> enclosed in percent signs; they are required only within unquoted text. Percent signs should not be used anywhere else, except to create a <a href="#dynamic-variables">dynamic variable reference</a> or <a href="Functions.htm#DynCall">dynamic function call</a>.
</p>
<p class="warning"><strong>Note:</strong> Only a plain variable name can be used. <a href="Objects.htm#Usage_Simple_Arrays">Array elements</a>, <a href="Objects.htm#Usage_Objects">properties</a> and other <a href="#expressions">expressions</a> are not supported.
</p>
</li>
  <li>
<p><code>,</code>: Comma is used to delimit (separate) the parameters of a command, with <a href="#escape-comma">some exceptions</a>. It has no special meaning when used in an assignment or comparison, so is interpreted literally in such cases.</p>
</li>
  <li>
<p><code>`</code>: An <a href="commands/_EscapeChar.htm">escape character</a> is usually used to indicate that the character immediately following it should be interpreted differently than it normally would. 例如, <code>`%</code> produces a literal percent sign and <code>`,</code> produces a literal comma. Some other common escape sequences produce special characters, such as <code>`t</code> (tab), <code>`n</code> (linefeed), and <code>`r</code> (carriage return).</p>
</li>
</ul>
<p><a href="#commands">Commands</a> accept a mixture of <a href="#text-parameters">unquoted text</a>, <a href="#outputvar-and-inputvar-parameters">variable names</a> and <a href="#numeric-parameters">numeric expressions</a>.</p>
<pre>Send, The time is %A_Hour% o'clock.
</pre>
<p><a href="commands/SetEnv.htm">Legacy assignment</a> assigns <a href="#unquoted-text">unquoted text</a> to a variable.</p>
<pre>Clipboard = This text is copied to the clipboard.
</pre>
<p><a href="#if-statement">If statements</a> perform an action only if the specified condition is met.</p>
<pre>If Var = Text value
</pre>
<p>There are also several other <a href="#control-flow">control flow statements</a> (such as loops) which use legacy syntax similar to commands.</p>

<h2 id="commands">命令</h2>
<p>A <em>command</em> is an instruction to carry out a specific predefined action. &quot;Command&quot; may also refer to a specific predefined action, such as <a href="commands/MsgBox.htm">MsgBox</a>. The set of available <a href="commands/index.htm">commands</a> is predefined and cannot be changed by the script.</p>
<p>A command is <em>called</em> simply by writing its name at the beginning of a line, optionally followed by parameters. 例如:</p>
<pre>MsgBox, The time is %A_Hour% o'clock.
</pre>
<p>The comma separating the command name from its parameters is optional, except in the following cases:</p>
<ul>
  <li>
<p>When it's necessary to prevent the line from being interpreted as a <a href="commands/SetEnv.htm">legacy assignment</a> or <a href="Variables.htm#AssignOp">assignment expression</a>.</p>
<pre>MsgBox, := This would be an assignment without the comma.
</pre>
</li>
  <li>
<p>When the first parameter is blank.</p>
<pre>MsgBox,, Second, Third
</pre>
</li>
  <li>
<p>When the command is alone at the top of a <a href="Scripts.htm#continuation">continuation section</a>.</p>
</li>
</ul>
<p>Each parameter of a command may accept different syntax, depending on the command. There are four types of parameters:</p>
<ul>
  <li>OutputVar</li>
  <li>InputVar</li>
  <li>Text</li>
  <li>Number</li>
</ul>
<p>In most cases the <a href="#-expression">percent prefix</a> can be used to pass an expression.</p>

<h3 id="outputvar-and-inputvar-parameters">OutputVar 和 InputVar 参数</h3>
<p><em>OutputVar</em> 和 <em>InputVar</em> parameters require a variable name or <a href="#dynamic-variables">dynamic variable reference</a>. 例如:</p>
<pre><em>; Replace all spaces with pluses:</em>
StringReplace, NewStr, OldStr, %A_Space%, +, All
</pre>
<p>该命令从 <em>OldStr</em>(InputVar) 中读取值并将结果存储在 <em>NewStr</em>(OutputVar) 中.</p>
<p class="warning"><strong>注意:</strong> 只有一个普通变量可以用作 <em>OutputVar</em>. <a href="Objects.htm#Usage_Simple_Arrays">数组元素</a>, <a href="Objects.htm#Usage_Objects">属性</a> 和其他的 <a href="#expressions">表达式</a> 不受支持.
</p>
<p><em>InputVar</em> parameters can accept an expression only when the <a href="#-expression">percent prefix</a> is used. However, the prefix is not supported in the <em>Var</em> parameters of <a href="#legacy-if">legacy If commands</a>, so <a href="commands/IfExpression.htm">If (expression)</a> should be used instead.</p>

<h3 id="text-parameters">文本参数</h3>
<p>文本参数接受<a href="#unquoted-text">不加引号的文本</a>. 例如:</p>
<pre>MsgBox, The time is %A_Hour% o'clock.
</pre>
<p id="escape-comma">因为逗号和百分号具有特殊的意义, 使用 <a href="commands/_EscapeChar.htm">转义序列</a> <code>`,</code> 去指定原义逗号 <code>`%</code>去指定原义百分号. 为了清楚起见, 最好总是转义任何旨在为原义的逗号, 但在以下情况下转义逗号是可选的:</p>
<ul>
  <li>在任何命令的最后一个参数.</li>
  <li>MsgBox 的 <em>Text</em> 参数, 它有智能逗号处理.</li>
</ul>
<p>要包含前导或尾随空格或制表符, 请使用内置变量 <a href="Variables.htm#Space">%A_Space%</a> 和 <a href="Variables.htm#Tab">%A_Tab%</a> 或强制表达式如 <code>% &quot; x &quot;</code>. <span class="ver">[v1.1.06+]</span>: 空格也可以通过在空格或制表符之前加上一个 <a href="commands/_EscapeChar.htm">转义序列</a> 来保留, 除了行末的空格之外.</p>
<p>文本参数也接受 <a href="#-expression">强制表达式</a>.</p>

<h3 id="numeric-parameters">数字参数</h3>
<p>Numeric parameters accept a literal number or an <a href="#expressions">expression</a>, and can be identified by phrasing like &quot;This parameter can be an expression.&quot;</p>
<p>For historical reasons, simple variable references alone or combined with digits are not interpreted as expressions. 例如:</p>
<pre>Sleep %n%000  <em>; Sleep for n seconds.</em>
Sleep %m%     <em>; Sleep for m milliseconds.</em>
</pre>
<p>To perform a <a href="#dynamic-variables">double-deref</a> in such cases, enclose the expression in parentheses: <code>Sleep (%m%)</code></p>
<p>Note that mixed-type parameters such as <a href="commands/SetTimer.htm">SetTimer's</a> second parameter, which sometimes accepts a number and sometimes accepts a string such as <code>On</code> or <code>Off</code>, are actually Text parameters, and as such, they do not accept expressions unless the <a href="#-expression">percent prefix</a> is used.</p>
<p>Although the <a href="#-expression">percent prefix</a> is usually unnecessary with numeric parameters, it is allowed.</p>

<h3 id="-expression">% 表达式</h3>
<p>Although purely numeric parameters accept an expression by default, all other parameters of commands do not. Specify a percent sign followed by a space or tab to force a parameter to accept an <a href="#expressions">expression</a>. 例如, all of the following are effectively identical because <a href="commands/Sleep.htm">Sleep</a>'s first parameter is expression-capable:</p>
<pre>Sleep MillisecondsToWait
Sleep %MillisecondsToWait%
Sleep % MillisecondsToWait
</pre>
<p class="warning"><strong>Note:</strong> Using the percent-space prefix in a <a href="#numeric-parameters">numeric parameter</a> does not necessarily force it to be an expression.</p>
<p>All parameters support the percent-space prefix except for:</p>
<ul>
  <li>The <em>Var</em> parameter of any <a href="#legacy-if">legacy If</a> command. Users can avoid confusion by always using <a href="commands/IfExpression.htm">if (expression)</a>.</li>
  <li><em>OutputVar</em> parameters, which accept a variable reference using the same syntax as expressions.</li>
</ul>
<p>Some users may find it easier to always force an expression, keeping to one consistent syntax (expression syntax) as much as possible.</p>

<h3 id="documentation-conventions">文档约定</h3>
<p>在每个命令文档的顶部, 通常有一个显示语法的块, 如下所示:</p>
<pre>Run, Target [, WorkingDir, Max|Min|Hide|UseErrorLevel, OutputVarPID]
</pre>
<p>The square brackets denote optional parameters; the brackets themselves must be omitted from the actual code.</p>
<p>Sometimes the value or values a parameter accepts are written directly in the syntax block. 例如, the third parameter of Run shown above accepts one or more of the words shown, as text. The pipe symbol denotes alternatives; the symbol itself should be omitted from the actual code. The exact syntax of the parameter is described in the <em>Parameters</em> table, and varies between commands.</p>

<h3 id="optional-parameters">可选参数</h3>
<p>Optional parameters can simply be left blank. The comma preceding an optional parameter can also be omitted if all subsequent parameters are omitted. 例如, the <a href="commands/Run.htm">Run</a> command can accept between one and four parameters. All of the following are valid:</p>
<pre>Run, notepad.exe, C:\
Run, notepad.exe,, Min
Run notepad.exe, , , notepadPID
</pre>

<h2 id="expressions-vs-legacy-syntax">表达式与传统语法</h2>
<p>许多命令参数默认情况下不接受表达式. 在参数的开始处使用 <a href="#-expression">百分号-空格 前缀</a> 为表达式来计算该参数. 在以下示例中, 表达式显示在第一行(在百分号 <em>之后</em> 开始), 第二行显示纯传统语法.</p>
<pre>MsgBox % 1+1  <em>; Shows &quot;2&quot;</em>
MsgBox   1+1  <em>; Shows &quot;1+1&quot;</em>
</pre>
<p>表达式中的原义文本总是用引号括起来。这些被称为 <em>加引号字符串</em>.</p>
<pre>MsgBox % &quot;This is text.&quot;
MsgBox    This is text.
</pre>
<p>表达式中的变量不包围在百分号中, 除非创建 <a href="#dynamic-variables">双重引用</a>.</p>
<pre>MsgBox %  A_AhkVersion
MsgBox   %A_AhkVersion%
</pre>
<p>变量不能在加引号的字符串中使用.</p>
<pre>MsgBox % &quot;Hello %A_UserName%.&quot;  <em>; Shows &quot;%A_UserName%&quot;</em>
MsgBox    Hello %A_UserName%.   <em>; Shows your username.</em>
</pre>
<p>作为代替, 通过将它们按顺序写入, 使用空格或制表符, 或被空格包围的点分隔, 将值 <a href="Variables.htm#concat"><em>连接</em></a> 起来.</p>
<pre>MsgBox % &quot;Hello &quot; . A_UserName . &quot;.&quot;  <em>; Shows your username.</em>
</pre>
<p>One alternative is to use the <a href="commands/Format.htm">Format</a> function, which can also format the parameter value in various ways.</p>
<pre>MsgBox % Format(&quot;Hello {1}.&quot;, A_UserName)  <em>; {} also works in place of {1}.</em>
</pre>
<p>A value is assigned to a variable with <code>:=</code> instead of <code>=</code>:</p>
<pre>MyVar := &quot;This is text.&quot;
MyVar = This is text.
</pre>
<p>Comparisons are performed using the same symbols as <a href="#legacy-if">legacy If</a>: <code>=</code>, <code>&lt;&gt;</code> or <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> and <code>&lt;=</code>.</p>
<pre>if (Var1 = Var2)
if Var1 = %Var2%
</pre>
<p>In an expression, both values can be simple values or complex sub-expressions. A comparison can also be combined with other conditions using <a href="Variables.htm#Operators">operators</a> such as <code>and</code> and <code>or</code> (which are equivalent to <code>&amp;&amp;</code> and <code>||</code>).</p>
<pre>if (Var1 &gt;= Low and Var1 &lt;= High)
if Var1 between %Low% and %High%  
</pre>

<h3 id="different-equals">不同的等号</h3>
<p>One common mistake is to write <code>=</code> where <code>:=</code> is needed. 例如:</p>
<pre>Total = A + B   <em>; Assigns the literal text &quot;A + B&quot;</em>
</pre>
<p>This can be difficult to avoid (at least until such time as the legacy assignment syntax is removed), but it may help to always use <code>:=</code> where an assignment is intended.</p>
<p>The equal sign (when not used with another symbol, such as <code>&lt;=</code>) has the following meanings:</p>
<ul>
  <li><a href="commands/SetEnv.htm">Legacy assignment</a>: <code>Var = Value</code></li>
  <li><a href="commands/IfEqual.htm">Legacy If equal</a>: <code>if Var = Value</code></li>
  <li><a href="Variables.htm#equal">Case-insensitive equal</a>: <code>if (Expr1 = Expr2)</code> (also valid in other expressions, not just <code>if</code>)</li>
  <li><a href="Variables.htm#comma">Assign after comma</a>: <code>x:=1, y=2, a=b=c</code> (all are assignments due to a special rule)</li>
  <li><a href="Functions.htm#DeclareInit">Declare and initialize</a>: <code>local x = Expr</code> (always accepts an expression)</li>
  <li><a href="Functions.htm#optional">Set parameter default value</a>: <code>MyFunc(Param=&quot;Default value&quot;) {</code>...</li>
</ul>
<p>The first two cases can be avoided by always using the <code>:=</code> <a href="Variables.htm#AssignOp">assignment operator</a> and <a href="commands/IfExpression.htm">if (expression)</a>.</p>
<p>For the last three cases, <code>:=</code> should have been used instead of <code>=</code>.</p>

<h3 id="commands-vs-functions">命令与函数</h3>
<p>In AutoHotkey v1, it is currently not possible to call a command from an expression, or to call a function using the <em>command syntax</em>. However, several commands have a function replacement.</p>
<table class="info">
  <tr><th>Command</th><th>Replacement</th></tr>
  <tr><td><a href="commands/FileAppend.htm">FileAppend</a></td><td><a href="commands/FileOpen.htm">FileOpen</a> and <a href="objects/File.htm#Write">File.Write</a></td></tr>
  <tr><td><a href="commands/FileGetAttrib.htm">FileGetAttrib</a></td><td><a href="commands/FileExist.htm">FileExist</a></td></tr>
  <tr><td><a href="commands/FileRead.htm">FileRead</a></td><td><a href="commands/FileOpen.htm">FileOpen</a> and <a href="objects/File.htm#Read">File.Read</a></td></tr>
  <tr><td><a href="commands/GetKeyState.htm">GetKeyState</a></td><td><a href="commands/GetKeyState.htm">GetKeyState</a> (the function returns 0 or 1, not &quot;U&quot; or &quot;D&quot;)</td></tr>
  <tr><td><a href="commands/IfExist.htm">IfExist</a></td><td><a href="commands/FileExist.htm">FileExist</a></td></tr>
  <tr><td><a href="commands/IfInString.htm">IfInString</a></td><td><a href="commands/InStr.htm">InStr</a></td></tr>
  <tr><td><a href="commands/WinActive.htm">IfWinActive</a></td><td><a href="commands/WinActive.htm">WinActive</a></td></tr>
  <tr><td><a href="commands/WinExist.htm">IfWinExist</a></td><td><a href="commands/WinExist.htm">WinExist</a></td></tr>
  <tr><td><a href="commands/StringGetPos.htm">StringGetPos</a></td><td><a href="commands/InStr.htm">InStr</a></td></tr>
  <tr><td><a href="commands/StringLen.htm">StringLen</a></td><td><a href="commands/StringLen.htm">StrLen</a></td></tr>
  <tr><td><a href="commands/StringReplace.htm">StringReplace</a></td><td><a href="commands/StringReplace.htm">StrReplace</a></td></tr>
  <tr><td><a href="commands/StringSplit.htm">StringSplit</a></td><td><a href="commands/StringSplit.htm">StrSplit</a></td></tr>
  <tr>
    <td><a href="commands/StringLower.htm">StringLower<br>StringUpper</a></td>
    <td><code><a href="commands/Format.htm">Format</a>(&quot;{:L}&quot;, input)</code>, <code>Format(&quot;{:U}&quot;, input)</code> or <code>Format(&quot;{:T}&quot;, input)</code></td>
  </tr>
  <tr>
    <td><a href="commands/StringLeft.htm">StringLeft</a><br><a href="commands/StringMid.htm">StringMid</a><br><a href="commands/StringLeft.htm">StringRight</a><br><a href="commands/StringTrimLeft.htm">StringTrimLeft<br>StringTrimRight</a></td>
    <td><a href="commands/SubStr.htm">SubStr</a></td>
  </tr>
</table>

<h2 id="control-flow">控制流语句</h2>
<p class="note">For a general explanation of control flow, see <a href="Concepts.htm#control-flow">Control Flow</a>.</p>
<p><a href="Concepts.htm#statement">Statements</a> are grouped together into a <a href="commands/Block.htm"><em>block</em></a> by enclosing them in braces <code>{}</code>, as in C, JavaScript and similar languages, but usually the braces must appear at the start of a line. Control flow statements can be applied to an entire block or just a single statement.</p>
<p>The <a href="Concepts.htm#body">body</a> of a control flow statement is always a single <em>group</em> of statements. A block counts as a single group of statements, as does a control flow statement and its body. The following related statements are also grouped with each other, along with their bodies: <code>If</code> with <code>Else</code>; <code>Loop</code>/<code>For</code> with <code>Until</code>; <code>Try</code> with <code>Catch</code> and/or <code>Finally</code>. In other words, when a group of these statements is used as a whole, it does not always need to be enclosed in braces (however, some coding styles always include the braces, for clarity).</p>
<p>Control flow statements which have a body and therefore must always be followed by a related statement or group of statements: <code>If</code>, <code>Else</code>, <code>Loop</code>, <code>While</code>, <code>For</code>, <code>Try</code>, <code>Catch</code> and <code>Finally</code>.</p>
<p id="control-flow-list">The following control flow statements exist:</p>
<ul>
  <li>A <a href="commands/Block.htm">block</a> (denoted by a pair of braces) groups zero or more statements to act as a single statement.</li>
  <li>An <a href="#if-statement">If statement</a> causes its body to be executed or not depending on a condition. It can be followed by an <a href="commands/Else.htm">Else</a> statement, which executes only if the condition was not met.</li>
  <li><a href="commands/Goto.htm">Goto</a> jumps to the specified label and continues execution.</li>
  <li><a href="commands/Gosub.htm">Gosub</a> calls a <a href="#subroutines">subroutine</a>.</li>
  <li><a href="commands/Return.htm">Return</a> returns from a <a href="#subroutines">subroutine</a> or function.</li>
  <li>A <a href="#loop-statement">Loop statement</a> (<a href="commands/Loop.htm">Loop</a>, <a href="commands/While.htm">While</a> or <a href="commands/For.htm">For</a>) executes its body repeatedly.
  <ul>
    <li><a href="commands/Break.htm">Break</a> exits (terminates) a loop.</li>
    <li><a href="commands/Continue.htm">Continue</a> skips the rest of the current loop iteration and begins a new one.</li>
    <li><a href="commands/Until.htm">Until</a> causes a loop to terminate when an expression evaluates to true. The expression is evaluated after each iteration.</li>
  </ul></li>
  <li>Exception handling:
  <ul>
    <li><a href="commands/Try.htm">Try</a> guards its body against runtime errors and exceptions thrown by the throw command.</li>
    <li><a href="commands/Catch.htm">Catch</a> executes its body after an exception is thrown within a try statement (and only if an exception is thrown).</li>
    <li><a href="commands/Finally.htm">Finally</a> executes its body when control is being transferred out of a try or catch statement's body.</li>
    <li><a href="commands/Throw.htm">Throw</a> throws an exception to be handled by try/catch or display an error dialog.</li>
  </ul></li>
</ul>

<h3 id="control-flow-vs-commands">控制流与命令</h3>
<p>Control flow statements have syntax resembling <a href="#commands">commands</a>, and are often referred to as such, but some differ from commands:</p>
<ul>
  <li>There are several types of <a href="#if-statement">If statement</a>, with each having different syntax.</li>
  <li><a href="commands/For.htm">For</a> and several types of <a href="#if-statement">If statement</a> use keywords or an operator instead of commas to separate some of their parameters.</li>
  <li>The opening brace of a <a href="commands/Block.htm">block</a> can be written at the end of the same line as an <a href="commands/IfExpression.htm">If (expression)</a>, <a href="commands/Else.htm">Else</a>, <a href="commands/Loop.htm">Loop Count</a>, <a href="commands/While.htm">While</a>, <a href="commands/For.htm">For</a>, <a href="commands/Try.htm">Try</a>, <a href="commands/Catch.htm">Catch</a> or <a href="commands/Finally.htm">Finally</a> statement (basically any control flow statement which does not use <a href="#legacy-syntax">legacy syntax</a>). This is referred to as the One True Brace (OTB) style. It is not supported by the other Loop sub-commands or <a href="#legacy-if">legacy If statement</a>, as the brace would be interpreted as a literal <code>{</code> character.</li>
  <li><a href="commands/Else.htm">Else</a>, <a href="commands/Try.htm">Try</a> and <a href="commands/Finally.htm">Finally</a> allow any valid statement to their right, in place of a parameter.</li>
  <li><a href="commands/IfExpression.htm">If (expression)</a> and <a href="commands/While.htm">While</a> allow an open parenthesis to be used immediately after the name. 例如, <code>if(expression)</code>.</li>
  <li><a href="commands/For.htm">For</a>, <a href="commands/While.htm">While</a>, <a href="commands/Until.htm">Until</a> and <a href="commands/Throw.htm">Throw</a> always accept expressions. They treat <code>%var%</code>, <code>%var%000</code> and similar as expressions, whereas <a href="#numeric-parameters">numeric parameters</a> of other commands do not. The requirement for backward-compatibility does not apply to these control flow statements as they are relatively new.</li>
</ul>

<h3 id="if-statement">If 语句</h3>
<p><a href="commands/IfExpression.htm">If (expression)</a> evaluates an expression and executes the following statement only if the result is true.</p>
<p id="legacy-if"><strong>Common cause of confusion:</strong> There are several other types of If statements, some of which look very similar to <em>If (expression)</em>. These should be avoided in new scripts. If in doubt, it is best to always begin the expression with an open-parenthesis. The &quot;legacy&quot; If statements are as follows:</p>
<ul>
  <li><a href="commands/IfEqual.htm">If Var</a></li>
  <li><a href="commands/IfEqual.htm">If Var <em>op</em> Value</a>, where <em>op</em> is one of the following operators: <code>=</code>, <code>&lt;&gt;</code>, <code>!=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>.</li>
  <li><a href="commands/IfBetween.htm">If Var [not] between Lower and Upper</a></li>
  <li><a href="commands/IfIn.htm">If Var [not] in/contains MatchList</a></li>
  <li><a href="commands/IfIs.htm">If Var is [not] Type</a></li>
</ul>
<p>Any If statement which does not match one of the usages shown above is interpreted as <a href="commands/IfExpression.htm">If (expression)</a>.</p>
<p>These are some common points of confusion related to legacy If statements:</p>
<ul>
  <li>Variable names must be enclosed in percent signs <em>only</em> on the right-hand side of the operator.</li>
  <li><code>between</code>, <code>in</code>, <code>contains</code> and <code>is</code> are only valid in this context; they cannot be used in <a href="#expressions">expressions</a>.</li>
  <li>Multiple conditions cannot be written on the same line (such as with the <code>and</code> operator).</li>
  <li>None of the parameters are expressions.</li>
</ul>
<p id="named-if">The following &quot;legacy&quot; named If statements also exist:</p>
<ul>
  <li><a href="commands/IfEqual.htm">IfEqual, IfNotEqual, IfLess, IfLessOrEqual, IfGreater and IfGreaterOrEqual</a></li>
  <li><a href="commands/IfExist.htm">If[Not]Exist</a></li>
  <li><a href="commands/IfInString.htm">If[Not]InString</a></li>
  <li><a href="commands/WinActive.htm">If[Not]WinActive</a></li>
  <li><a href="commands/WinExist.htm">If[Not]WinExist</a></li>
  <li><a href="commands/IfMsgBox.htm">IfMsgBox</a></li>
</ul>
<p>With the exception of IfMsgBox, these are all obsolete and generally should be avoided in new scripts.</p>
<p>Named If statements allow a <a href="#commands">command</a> to be written on the same line, but mispelled command names are treated as literal text. Such errors may be difficult to detect.</p>

<h3 id="loop-statement">Loop 语句</h3>
<p>There are several types of loop statements:</p>
<ul>
  <li><a href="commands/Loop.htm">Loop Count</a> executes a statement repeatedly: either the specified number of times or until break is encountered.</li>
  <li><a href="commands/LoopReg.htm">Loop Reg</a> retrieves the contents of the specified registry subkey, one item at a time.</li>
  <li><a href="commands/LoopFile.htm">Loop Files</a> retrieves the specified files or folders, one at a time.</li>
  <li><a href="commands/LoopParse.htm">Loop Parse</a> retrieves substrings (fields) from a string, one at a time.</li>
  <li><a href="commands/LoopReadFile.htm">Loop Read</a> retrieves the lines in a text file, one at a time.</li>
  <li><a href="commands/While.htm">While</a> executes a statement repeatedly until the specified expression evaluates to false. The expression is evaluated before each iteration.</li>
  <li><a href="commands/For.htm">For</a> executes a statement once for each value or pair of values returned by an enumerator, such as each key-value pair in an object.</li>
</ul>
<p><a href="commands/Break.htm">Break</a> exits (terminates) a loop, effectively jumping to the next line after the loop's body.</p>
<p><a href="commands/Continue.htm">Continue</a> skips the rest of the current loop iteration and begins a new one.</p>
<p><a href="commands/Until.htm">Until</a> causes a loop to terminate when an expression evaluates to true. The expression is evaluated after each iteration.</p>
<p>A <a href="#labels">label</a> can be used to &quot;name&quot; a loop for <a href="commands/Continue.htm">Continue</a> and <a href="commands/Break.htm">Break</a>. This allows the script to easily continue or break out of any number of nested loops without using <a href="commands/Goto.htm">Goto</a>.</p>
<p>The built-in variable <strong>A_Index</strong> contains the number of the current loop iteration. It contains 1 the first time the loop's body is executed. For the second time, it contains 2; and so on. If an inner loop is enclosed by an outer loop, the inner loop takes precedence. A_Index works inside all types of loops, but contains 0 outside of a loop.</p>
<p>For some loop types, other built-in variables return information about the current loop item (registry key/value, file, substring or line of text). These variables have names beginning with <strong>A_Loop</strong>, such as A_LoopFileName and A_LoopReadLine. Their values always correspond to the most recently started (but not yet stopped) loop of the appropriate type. 例如, A_LoopField returns the current substring in the innermost parsing loop, even if it is used inside a file or registry loop.</p>
<pre>t := &quot;column 1`tcolumn 2`nvalue 1`tvalue 2&quot;
Loop Parse, t, `n
{
    rowtext := A_LoopField
    rownum := A_Index  <em>; Save this for use in the second loop, below.</em>
    Loop Parse, rowtext, `t
    {
        MsgBox %rownum%:%A_Index% = %A_LoopField%
    }
}
</pre>
<p>Loop variables can also be used outside the body of a loop, such as in a function or subroutine which is called from within a loop.</p>

<h3 id="not-control-flow">非控制流</h3>
<p>像指令, 标签(包括热键和热字符串) 和没有赋值的声明 declarations without assignments are processed when the script is loaded from file, they are not subject to control flow. In other words, they take effect unconditionally, before the script ever executes any control flow statements. Similarly, the #If directives such as <a href="commands/_If.htm">#IfWinActive</a> cannot affect control flow; they merely set the criteria for any hotkey labels and hotstrings specified in the code. A hotkey's criteria is evaluated each time it is pressed, not when the #If directive is encountered in the code.</p>

<h2 id="structure-of-a-script">脚本的结构</h2>

<h3 id="auto-execute-section">自动执行部分</h3>
<p>After the script has been loaded, it begins executing at the top line, continuing until a <a href="commands/Return.htm">Return</a>, <a href="commands/ExitApp.htm">Exit</a>, the script's first <a href="Hotkeys.htm">hotkey/hotstring label</a>, or the physical end of the script is encountered (whichever comes first). This top portion of the script is referred to as the <em>auto-execute section</em>, but it is really just a <a href="#subroutines">subroutine</a> which is called after program startup.</p>
<p class="warning"><strong>Note:</strong> While the script's <em>first</em> hotkey/hotstring label has the same effect as <a href="commands/Return.htm">return</a>, other hotkeys and labels do not.</p>
<p>The auto-execute section is often used to configure settings which apply to every newly launched <a href="misc/Threads.htm">thread</a>. For details, see <a href="Scripts.htm#auto">The Top of the Script</a>.</p>

<h3 id="subroutines">子程序</h3>
<p>A <em>subroutine</em> (or sub) is a reusable block of code which can be <em>called</em> to perform some task.</p>
<p>Scripts use subroutines to define what should happen when a particular hotkey is pressed or some other event occurs. Scripts can also call subroutines directly, by using <a href="commands/Gosub.htm">Gosub</a>.</p>
<p>Any <a href="#labels">label</a> can be used as the starting point of a subroutine. A subroutine has no explicitly marked ending point, but instead ends if and when control is returned to the subroutine's caller by <a href="commands/Return.htm">Return</a> or when the thread is exited.  例如:</p>
<pre>gosub Label1

Label1:
MsgBox %A_ThisLabel%
return
</pre>
<p>Note that as labels have no effect when reached during normal execution, in this example a MsgBox would be shown twice: once while the subroutine is running and again after it returns. One important consequence is that you cannot define one subroutine inside another subroutine, because the &quot;body&quot; of the inner subroutine would execute automatically and then <em>return</em>, effectively terminating the outer subroutine.</p>
<p>Subroutines should typically be defined separately to any other block of code, but can also be <a href="Functions.htm#gosub">defined inside a function</a>, allowing the subroutine access to that function's static variables (and local variables, but only while the function is running).</p>
<p class="warning"><strong>Note:</strong> Subroutines defined inside a function have certain limitations regarding the use of local variables and <a href="#dynamic-variables">dynamic variable references</a>, including <a href="commands/Gui.htm#Events">Gui control variables</a>. For details, see <a href="Functions.htm#gosub">Using Subroutines Within a Function</a>.
</p>

<h3 id="user-defined-functions">用户自定义函数</h3>
<p>Generally speaking, a <a href="Functions.htm">function</a> is a kind of subroutine. However, within the AutoHotkey documentation, &quot;subroutine&quot; typically refers to the kind of subroutine defined by a label (described above).</p>
<p>User-defined functions differ from subroutines in that they can <em>accept parameters</em> and <em>return a value</em>, and they can have <a href="Functions.htm#Local">local variables</a>. They can be called either by a <a href="#function-calls">function call</a> within the script or by the program itself, such as if a function was passed to the <a href="commands/Hotkey.htm">Hotkey</a> or <a href="commands/SetTimer.htm">SetTimer</a> commands.</p>
<p>Functions are defined using syntax resembling a function call followed by a block of code enclosed in braces:</p>
<pre>MyFunction(FirstParameter, Second, ByRef Third, Fourth:=&quot;&quot;)
{
	...
	return &quot;a value&quot;
}
</pre>
<p>As with function calls, there must be no space between the function name and open-parenthesis.</p>
<p>The line break between the close-parenthesis and open-brace is optional. There can be any amount of whitespace or comments between the two.</p>
<p><a href="Functions.htm#ByRef">ByRef</a> indicates that the parameter accepts a variable reference, making that parameter an alias for whichever variable the caller passes. If the caller does not pass a variable, the parameter acts as a normal local variable. ByRef parameters can also be optional.</p>
<p><a href="Functions.htm#optional">Optional</a> parameters are specified by following the parameter name with <code>:=</code> or <code>=</code> and a default value, which must be a literal quoted string, a number, <code>true</code> or <code>false</code>. The operators <code>:=</code> and <code>=</code> are interchangeable for historical reasons, but it is best to use <code>:=</code> for consistency with assignment in expressions.</p>
<p>The function can <a href="Functions.htm#return">return a value</a>. If it does not, the default return value is an empty string.</p>
<p>A function cannot be defined inside another function. Otherwise, the position of a function definition does not matter; any function defined within the script can be called from anywhere else.</p>
<p class="note">See <a href="Functions.htm">Functions</a> for much more detail.</p>

<h3 id="-include">#Include</h3>
<p>The <a href="commands/_Include.htm">#Include</a> directive causes the script to behave as though the specified file's contents are present at this exact position. This is often used to organise code into separate files, or to make use of script libraries written by other users.</p>
<p class="warning"><strong>Note:</strong> The following paragraphs detail some common points of confusion.
</p>
<p>When using #Include, it is important to consider what effect the file's contents would have if placed at that position, since #Include will have the same effect. For instance:</p>
<ul>
  <li>
<p>#Include generally should not be used in the middle of a subroutine or function.</p>
</li>
  <li>
<p>The use of #Include in the script's <a href="#auto-execute-section">auto-execute section</a> requires special consideration, because the auto-execute section is essentially just a subroutine. Execution of a subroutine halts if it reaches a <code>return</code>, regardless of which file that <code>return</code> is in. Similarly, if the file contains a hotkey/hotstring, it may be considered the script's <em>first</em> hotkey/hotstring, which would act like <code>return</code>.</p>
</li>
  <li>
<p>The script only has one <a href="#auto-execute-section">auto-execute section</a>, not one per file.</p>
</li>
</ul>
<p>#Include can be safely used within the <a href="#auto-execute-section">auto-execute section</a> to include files which contain only function definitions, since function definitions (but not function calls) are skipped over during execution. If a file contains other code, one can avoid breaking the auto-execute section by skipping over the file's contents with <a href="commands/Goto.htm">Goto</a>.</p>
<p>Unlike in C/C++, #Include does nothing if the file has already been included by a previous directive. To include the contents of the same file multiple times, use <a href="commands/_Include.htm">#IncludeAgain</a>.</p>
<p>Script files containing functions can be <em>automatically</em> included without having to use #Include, if they are saved in a standard location and named appropriately. The effect is similar to using #Include at the end of the main script file. For details, see <a href="Functions.htm#lib">Libraries of Functions</a>.</p>

<h2 id="misc">杂项</h2>

<h3 id="dynamic-variables">动态变量</h3>
<p>A <em>dynamic variable reference</em> takes a text value and interprets it as the name of a variable.</p>
<p>The most common form of dynamic variable reference is called a <em>double reference</em> or <em>double-deref</em>. Before performing a double reference, the name of the target variable is stored in a second variable. This second variable can then be used to assign a value to the target variable indirectly, using a double reference. 例如:</p>
<pre>target := 42
second := &quot;target&quot;
MsgBox   %second%  <em>; Normal (single) variable reference in text =&gt; target</em>
MsgBox %  second   <em>; Normal (single) variable reference in an expression =&gt; target</em>
MsgBox % %second%  <em>; Double-deref in an expression =&gt; 42</em>
</pre>
<p>At first, it would appear that percent signs have a different meaning depending on whether they are used in text or in an expression. However, it may make more sense to think of <code>%second%</code> as being replaced with the contents of the variable <code>second</code> in <em>both</em> cases:</p>
<ul>
  <li><code>MsgBox %second%</code> &rarr; <code>MsgBox target</code>: Shows &quot;target&quot;.</li>
  <li><code>MsgBox % %second%</code> &rarr; <code>MsgBox % target</code>: Shows the contents of <code>target</code>, i.e. &quot;42&quot;.</li>
</ul>
<p>Currently, <code>second</code> must always contain a variable name in the second case; arbitrary expressions are not supported.</p>
<p>A dynamic variable reference can also take one or more pieces of literal text and the content of one or more variables, and join them together to form a single variable name. This is done simply by writing the pieces of the name and percent-enclosed variables in sequence, without any spaces. 例如, <code>MyArray%A_Index%</code> or <code>MyGrid%X%_%Y%</code>. This is used to access <em>pseudo-arrays</em>, described below.</p>
<p>For a description of how dynamic variable references inside functions are resolved, see <a href="Functions.htm#Dynamic">Functions: More about locals and globals</a>.</p>

<h4 id="pseudo-arrays">伪数组</h4>
<p><em>伪数组</em> 实际上只是一堆分开的变量, 但是有一个命名模式, 可以像数组元素一样使用它. 例如:</p>
<pre>MyArray1 = A
MyArray2 = B
MyArray3 = C
Loop 3
	MsgBox % MyArray%A_Index%  <em>; Shows A, then B, then C.</em>
</pre>
<p>由于单个元素只是普通变量, 所以可以赋值或获取一个值, 但不能 <em>删除</em> 或 <em>插入</em> 元素. 因为伪数组本身并不存在, 所以不能将它传递给函数或从函数返回, 或者作为一个整体进行复制. 由于这些原因, 通常建议在可能的情况下使用 <a href="Objects.htm#Usage_Simple_Arrays">普通数组</a>.</p>

<h4 id="associative-pseudo-arrays">关联伪数组</h4>
<p>The &quot;index&quot; used to form the final variable name does not have to be numeric; it could instead be a letter or keyword, making the pseudo-array similar to an <a href="Objects.htm#Usage_Associative_Arrays">associative array</a> or an <a href="Objects.htm">object</a>. The following example creates a pseudo-array with elements &quot;Left&quot;, &quot;Top&quot;, &quot;Right&quot; and &quot;Bottom&quot;:</p>
<pre>SysGet, WA, MonitorWorkArea
MsgBox, Left: %WALeft% -- Top: %WATop% -- Right: %WARight% -- Bottom: %WABottom%.
</pre>

<h4 id="commands-which-create-pseudo-arrays">创建伪数组的命令</h4>
<p>有几个命令可以创建关联的伪数组:</p>
<ul>
  <li><a href="commands/GuiControlGet.htm">GuiControlGet Pos</a>.</li>
  <li><a href="commands/RegExMatch.htm">RegExMatch</a>, except when given the <code>O)</code> option, which causes it to output a single object containing all match information.</li>
  <li><a href="commands/SysGet.htm">SysGet Monitor/MonitorWorkArea</a>, 如上所示.</li>
  <li><a href="commands/StringSplit.htm">StringSplit</a>. 新的脚本应该使用 <a href="commands/StringSplit.htm">StrSplit()</a> 作为代替, 因为它创建的是 <a href="Objects.htm#Usage_Simple_Arrays">普通数组</a>.</li>
  <li><a href="commands/WinGet.htm">WinGet List</a>.</li>
</ul>
<p class="warning"><strong>警告:</strong> These commands do not follow the same rules as <em>dynamic variable references</em>. If used within a function, the resulting pseudo-array is either entirely global or entirely local, depending only on the first element (or base name) of the array.  Some of the variables in the pseudo-array may be inaccessible if they are not individually declared. 有关详细信息, 请参阅 <a href="Functions.htm#PseudoArrays">Functions: More about locals and globals</a>.
</p>
<p>AutoHotkey also creates one global pseudo-array to contain any <a href="Scripts.htm#cmd_args">command line parameters</a> that were passed to the script.</p>

<h3 id="labels">标签</h3>
<p>标签标识只是一行代码, 可以用作 <a href="commands/Goto.htm">Goto</a> 目标或形成 <a href="#subroutines">子程序</a>. 有三种标签: 普通标签, <a href="Hotkeys.htm">热键</a> 标签和 <a href="Hotstrings.htm">热字符串</a> 标签.</p>
<p>普通标签由一个名称后跟一个冒号组成.</p>
<pre>this_is_a_label:
</pre>
<p>热键标签由一个热键后跟双冒号组成.</p>
<pre>^a::
</pre>
<p>热字符串标签由一个冒号, 零个或多个 <a href="Hotstrings.htm#Options">选项</a>, 另一个冒号, 缩写字符和双冒号组成.</p>
<pre>:*:btw::
</pre>
<p>通常, 除了空格和注释之外, 其他代码不能与标签一起写在同一行上. 然而:</p>
<ul>
  <li>一个热键标签可以直接跟随一个命令或其他语句来创建 <em>一行</em> 热键. 换句话说, 如果一个命令, 赋值或表达式 与热键标签位于同一行上, 它的行为就好像跟着 <code>return</code> 一样.</li>
  <li>热键和写在双冒号右边的 <a href="KeyList.htm">键名</a> 实际上是 <a href="misc/Remap.htm"><em>重映射</em></a>, 这是 <a href="misc/Remap.htm#actually">热键对</a> 的快速写法. 例如, <code>a::b</code> 创建热键和标签 <code>*a</code> 和 <code>*a Up</code>, 并不创建名为 <code>a</code> 的标签.</li>
  <li>热字符串和写在最后的双冒号的右边的文本是一个 <em>自动替换</em> 热字符串. 自动替换热字符串不作为标签.</li>
</ul>
<p>有关详细信息, 请参阅 <a href="misc/Labels.htm">标签</a>.</p>

</body>
</html>